[[taint-analysis]]
include::attributes.adoc[]

= Taint Analysis

Tai-e provides a configurable and powerful taint analysis for detecting security vulnerabilities.
We develop taint analysis based on the pointer analysis framework, so that it can benefit from the techniques (e.g., various context sensitivity and heap abstraction techniques) and implementations (e.g., the handling of complex language features such as reflection and lambda functions) provided by the pointer analysis framework.
In this documentation, we introduce how to use our taint analysis.

== Enabling Taint Analysis
In Tai-e, taint analysis is designed and implemented as a plugin of pointer analysis framework.
To enable taint analysis, just start pointer analysis with option `taint-config`, for example:

[source,indent=0,subs="verbatim"]
----
-a pta=...;taint-config:<path/to/config>;...
----

then Tai-e will run taint analysis (together with pointer analysis) using a configuration file specified by `<path/to/config>` (if you need to specify multiple configuration files, please see <<Multiple Configuration Files>>).
We will introduce how to write a configuration file in the next section.

NOTE: You could use various pointer analysis techniques to obtain different precision/efficiency tradeoffs.
For more information, see <<pointer-analysis-framework#pointer-analysis-framework,Pointer Analysis Framework>>.

== Configuring Taint Analysis
In this section, we introduce how to configure sources, sinks, taint transfers, and sanitizers of the taint analysis through a configuration file written in YAML.
As an example. you could first take a look at https://github.com/pascal-lab/Tai-e/blob/master/src/test/resources/pta/taint/taint-config.yml[taint-config.yml] from our test cases to get a general impression.

=== General Notions
We first introduce some general notions used in the configuration.

==== Type
You may write following types in configuration.

[cols="1,2,2"]
|===
| Type | Description | Examples

| Class type
| Fully-qualified class name.
| `java.lang.String`, `org.example.MyClass`

| Array type
| A type following by one or more `[]`, where the number of `[]` equals the number of the array dimension.
| `java.lang.String[]`, `org.example.MyClass[][]`

| Primitive type
| The primitive types in Java.
| `int`, `char`, etc.
|===

==== Method Signature
In the configuration, we use method signature to uniquely identify a method in the program being analyzed.
The format of a method signature is given below:

[source,indent=0,subs="verbatim"]
----
<CLASS_TYPE: RETURN_TYPE METHOD_NAME(PARAMETER_TYPES)>
----

* `CLASS_TYPE`: The class in which the method is declared.
* `RETURN_TYPE`: The return type of the method.
* `METHOD_NAME`: The name of the method.
* `PARAMETER_TYPES`: The list of parameters types of the method.
Multiple parameter types are separated by `,` (NOTE: do not insert spaces around `,`).
If the method has no parameters, just write `()`.

For example, the signatures of methods `equals` and `toString` of `Object` are:

[source,indent=0,subs="verbatim"]
----
<java.lang.Object: boolean equals(java.lang.Object)>
<java.lang.Object: java.lang.String toString()>
----

==== Field Signature
Similar to methods, we use field signature to uniquely identify a field in the program being analyzed.
The format of a field signature is given below:

[source,indent=0,subs="verbatim"]
----
<CLASS_TYPE: FIELD_TYPE FIELD_NAME>
----

* `CLASS_TYPE`: The class in which the method is declared.
* `FIELD_TYPE`: The type of the field.
* `FIELD_NAME`: The name of the field.

For example, the signature of the field `info` below

[source,java,indent=0,subs="verbatim"]
----
package org.example;

class MyClass {
    String info;
}
----

is

[source,indent=0,subs="verbatim"]
----
<org.example.MyClass: java.lang.String info>
----

==== Variable Index
When configuring taint analysis, we usually need to specify a variable of a call site or a method, and this can be done by _variable index_.

===== Variable Index of A Call Site
We classify variables at a call site into following kinds:

[cols="1,3,1"]
|===
| Kind | Description | Index

| Result variable
| The variable that receives the result of the method call, i.e., the LHS variable of the call site.
| `result`

| Base variable
| The variable that points to the receiver object of the method call. This variable is absent for static method calls.
| `base`

| Arguments
| The arguments of the call site, counting from 0.
| `0`, `1`, `2`, ...
|===

For example, for a method call

[source,java,indent=0,subs="verbatim"]
----
r = o.foo(p, q);
----

* The index of variable `r` is `result`.
* The index of variable `o` is `base`.
* The indexes of variables `p` and `q` are `0` and `1`.

===== Variable Index of A Method
Currently, we support specifying parameters of a method using indexes.
Similar to arguments of a call site, the parameters are counted from 0.
For example, the indexes of parameters `t`, `s`, and `o` of method `foo` below are `0`, `1`, and `2`.

[source,java,indent=0,subs="verbatim"]
----
package org.example;

class MyClass {
    void foo(T t, String s, Object o) {
        ...
    }
}
----

=== Sources

Taint objects are generated by sources.
In the configuration file, sources are specified as a list of source entries following key `sources`, for example:

[source,yaml,indent=0,subs="verbatim"]
----
sources:
  - { kind: call, method: "<javax.servlet.ServletRequestWrapper: java.lang.String getParameter(java.lang.String)>", index: result }
  - { kind: param, method: "<com.example.Controller: java.lang.String index(javax.servlet.http.HttpServletRequest)>", index: 0 }
  - { kind: field, field: "<SourceSink: java.lang.String info>" }
----

Our taint analysis supports several kinds of sources, as introduced in the next sections.

==== Call Sources

This should be the most-commonly used source kind, for the cases that the taint objects are generated at call sites.
The format of this kind of sources is:

[source,yaml,indent=0,subs="verbatim"]
----
- { kind: call, method: METHOD_SIGNATURE, index: INDEX, type: TYPE }
----

If you write such a source in the configuration, then when the taint analysis finds that method  `METHOD_SIGNATURE` is called by call site _l_, it will generate a taint object of type `TYPE` for the variable specified by `INDEX` at call site _l_.
For how to specify `METHOD_SIGNATURE` and `INDEX`, please see <<Method Signature>> and <<Variable Index of A Call Site>>.

`type: TYPE` in the call source configuration is *optional*.
When it is omitted, the taint analysis will use corresponding declared type from the method (return type for _result variable_, declaring class type for _base variable_, and parameter types for _arguments_) as the type for the generated taint object.

==== Parameter Sources

Some methods, e.g., entry methods, have no explicit call sites in the program, so we cannot generate taint objects for the variables at their call sites.
However, it is sometime useful to generate taint objects for their parameters.
To meet such needs, our taint analysis allows you to configure parameter sources:

[source,yaml,indent=0,subs="verbatim"]
----
- { kind: param, method: METHOD_SIGNATURE, index: INDEX, type: TYPE }
----

If you write such a source in the configuration, then when the taint analysis finds that method `METHOD_SIGNATURE` is reachable, it will generate a taint object of type `TYPE` for the parameter specified by `INDEX`.
For how to specify `METHOD_SIGNATURE` and `INDEX`, please see <<Method Signature>> and <<Variable Index of A Method>>.

Similar to call sources, `type: TYPE` in the parameter source configuration is *optional*.

==== Field Sources

Our taint analysis also supports users to specify fields as taint sources using format:

[source,yaml,indent=0,subs="verbatim"]
----
- { kind: field, field: FIELD_SIGNATURE, type: TYPE }
----

If you write such a source in the configuration, then when the taint analysis finds that field `FIELD_SIGNATURE` is loaded to variable `v` (e.g., `v = o.f`), it will generate a taint object of type `TYPE` for `v`.
For how to specify `FIELD_SIGNATURE`, please see <<Field Signature>>.
Similarly, `type: TYPE` in the field source configuration is also *optional*.

=== Sinks

=== Taint Transfers

=== Sanitizers

// TODO: === Call-Site Mode

=== Multiple Configuration Files

== Output of Taint Analysis

console:

[source,indent=0,subs="verbatim"]
----
Detected n taint flow(s):
TaintFlow{SOURCE_POINT -> SINK_POINT}
...
----

[source,indent=0,subs="verbatim"]
----
Detected 1 taint flow(s):
TaintFlow{<Server: void main(java.lang.String[])>[12@L8] temp$4 = invokestatic Server.getInput()/result -> <org.apache.logging.log4j.core.net.JndiManager: java.lang.Object lookup(java.lang.String)>[1@L172] $r3 = invokeinterface $r2.lookup(name)/0}
----

_taint flow graph_ (TFG)

// TODO: == Troubleshooting
