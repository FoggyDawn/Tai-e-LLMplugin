[[taint-analysis]]
include::attributes.adoc[]

= How to Use Taint Analysis?

Tai-e provides a configurable and powerful taint analysis for detecting security vulnerabilities.
We develop taint analysis based on the pointer analysis framework, enabling it to leverage advanced techniques (including various context sensitivity and heap abstraction techniques) and implementations (including the handling of complex language features such as reflection and lambda functions) provided by the pointer analysis framework.
This documentation is dedicated to providing guidance on using our taint analysis.

== Enabling Taint Analysis

In Tai-e, taint analysis is designed and implemented as a plugin of pointer analysis framework.
To enable taint analysis, simply start pointer analysis with option `taint-config`, for example:

[source]
----
-a pta=...;taint-config:<path/to/config>;...
----

then Tai-e will run taint analysis (together with pointer analysis) using a configuration file specified by `<path/to/config>` (if you need to specify multiple configuration files, please refer to <<Multiple Configuration Files>>).
In the upcoming section, we will provide a comprehensive guide on crafting a configuration file.

TIP: You could use various pointer analysis techniques to obtain different precision/efficiency tradeoffs.
For additional details, please refer to <<pointer-analysis-framework#pointer-analysis-framework,Pointer Analysis Framework>>.

== Configuring Taint Analysis

In this section, we present instructions on configuring sources, sinks, taint transfers, and sanitizers for the taint analysis using a YAML configuration file.
To get a broad understanding, you can start by examining the https://github.com/pascal-lab/Tai-e/blob/master/src/test/resources/pta/taint/taint-config.yml[taint-config.yml] file from our test cases as an illustrative example.

NOTE: Certain configuration values include special characters, such as spaces, `[`, and `]`.
To ensure these values are correctly interpreted by the YAML parser, please make sure to enclose them within *quotation marks*.

=== Basic Concepts

We first present several basic concepts employed in the configuration.

==== Type

You may write following types in configuration:

[cols="1,2,2"]
|===
| Type | Format | Examples

| Class type
| Fully-qualified class name.
| `java.lang.String`, `org.example.MyClass`

| Array type
| A type following by one or more `[]`, where the number of `[]` equals the number of the array dimension.
| `java.lang.String[]`, `org.example.MyClass[][]`, `char[]`

| Primitive type
| Primitive type names in Java.
| `int`, `char`, etc.
|===

==== Method Signature

In the configuration, we employ a method signature to provide a unique identifier for a method in the analyzed program.
The format of a method signature is given below:

[source]
----
<CLASS_TYPE: RETURN_TYPE METHOD_NAME(PARAMETER_TYPES)>
----

* `CLASS_TYPE`: The class in which the method is declared.
* `RETURN_TYPE`: The return type of the method.
* `METHOD_NAME`: The name of the method.
* `PARAMETER_TYPES`: The list of parameters types of the method.
Multiple parameter types are separated by `,` (Do not insert spaces around `,`!).
If the method has no parameters, just write `()`.

For example, the signatures of methods `equals` and `toString` of `Object` are:

[source]
----
<java.lang.Object: boolean equals(java.lang.Object)>
<java.lang.Object: java.lang.String toString()>
----

==== Field Signature

Just like methods, field signatures serve the purpose of uniquely identifying fields within the analyzed program.
The format of a field signature is given below:

[source]
----
<CLASS_TYPE: FIELD_TYPE FIELD_NAME>
----

* `CLASS_TYPE`: The class in which the field is declared.
* `FIELD_TYPE`: The type of the field.
* `FIELD_NAME`: The name of the field.

For example, the signature of the field `info` below

[source,java]
----
package org.example;

class MyClass {
    String info;
}
----

is

[source]
----
<org.example.MyClass: java.lang.String info>
----

==== Variable Index

When setting up taint analysis, it's typically necessary to indicate a variable at a call site or within a method.
This can be accomplished using _variable index_.

===== Variable Index of A Call Site

We classify variables at a call site into several kinds, and provide their corresponding indexes below:

[cols="1,3,1"]
|===
| Kind | Description | Index

| Result variable
| The variable that receives the result of the method call, also known as the left-hand side (LHS) variable of the call site.
| `result`

| Base variable
| The variable that points to the receiver object of the method call. Note that this variable is absent in the cases of static method calls.
| `base`

| Arguments
| The arguments of the call site, indexed starting from 0.
| `0`, `1`, `2`, ...
|===

For example, for a method call

[source,java]
----
r = o.foo(p, q);
----

* The index of variable `r` is `result`.
* The index of variable `o` is `base`.
* The indexes of variables `p` and `q` are `0` and `1`.

===== Variable Index of A Method

Currently, we support specifying parameters of a method using indexes.
Similar to arguments of a call site, the parameters are indexed starting from 0.
For example, the indexes of parameters `t`, `s`, and `o` of method `foo` below are `0`, `1`, and `2`.

[source,java]
----
package org.example;

class MyClass {
    void foo(T t, String s, Object o) {
        ...
    }
}
----

=== Sources
Taint objects are generated by sources.
In the configuration file, sources are specified as a list of source entries following key `sources`, for example:

[source,yaml]
----
sources:
  - { kind: call, method: "<javax.servlet.ServletRequestWrapper: java.lang.String getParameter(java.lang.String)>", index: result }
  - { kind: param, method: "<com.example.Controller: java.lang.String index(javax.servlet.http.HttpServletRequest)>", index: 0 }
  - { kind: field, field: "<SourceSink: java.lang.String info>" }
----

Our taint analysis supports several kinds of sources, as introduced in the next sections.

==== Call Sources

This should be the most-commonly used source kind, for the cases that the taint objects are generated at call sites.
The format of this kind of sources is:

[source,yaml,subs="+normal"]
----
- { kind: call, method: METHOD_SIGNATURE, index: INDEX, [underline]#type: TYPE# }
----

If you write such a source in the configuration, then when the taint analysis finds that method  `METHOD_SIGNATURE` is invoked at call site _l_, it will generate a taint object of type `TYPE` for the variable indicated by `INDEX` at call site _l_.
For how to specify `METHOD_SIGNATURE` and `INDEX`, please refer to <<Method Signature>> and <<Variable Index of A Call Site>>.

We use [underline]#underlining# to emphasize the optional nature of [underline]#`type: TYPE`# in call source configuration.
When it is not specified, the taint analysis will utilize the corresponding declared type from the method.
This includes using the return type for the _result variable_, the declaring class type for the _base variable_, and the parameter types for _arguments_ as the type for the generated taint object.

TIP: Someone may wonder why we need to include `type: TYPE` in the configuration for taint objects when we can already obtain the declared type from the method.
This is because the type of taint objects should align with the corresponding actual objects.
However, in certain situations, the actual object type related to the method might be a *subclass* of the declared type.
Therefore, we use `type: TYPE` to specify the precise object type in such cases.
As an illustration, consider the code snippet below.
In this snippet, the source method `Z.source()` declares its return type as `X`, but it actually returns an object of type `Y`, which is a subclass of `X`.
Therefore, we can define `type: Y` for the taint object generated by `Z.source()` method.

[source,java]
----
class X {...}

class Y extends X { ... }

class Z {
    X source() {
        ...
        return new Y();
    }
}
----

NOTE: Throughout the rest of this documentation, we will also use [underline]#underlining# to indicate *optional* elements.
The reasons for specifying `type: TYPE` in other cases are similar to those for call sources.
In these situations, the type of generated taint object may be a *subclass* of the corresponding declared type.

==== Parameter Sources

Some methods, e.g., entry methods, have no explicit call sites in the program, so we cannot generate taint objects for the variables at their call sites.
However, it is sometime useful to generate taint objects for their parameters.
To meet such needs, our taint analysis allows you to configure parameter sources:

[source,yaml,subs="+normal"]
----
- { kind: param, method: METHOD_SIGNATURE, index: INDEX, [underline]#type: TYPE# }
----

If you write such a source in the configuration, then when the taint analysis finds that method `METHOD_SIGNATURE` is reachable, it will generate a taint object of type `TYPE` for the parameter specified by `INDEX`.
For how to specify `METHOD_SIGNATURE` and `INDEX`, please see <<Method Signature>> and <<Variable Index of A Method>>.

==== Field Sources
Our taint analysis also supports users to specify fields as taint sources using format:

[source,yaml,subs="+normal"]
----
- { kind: field, field: FIELD_SIGNATURE, [underline]#type: TYPE# }
----

If you write such a source in the configuration, then when the taint analysis finds that field `FIELD_SIGNATURE` is loaded to variable `v` (e.g., `v = o.f`), it will generate a taint object of type `TYPE` for `v`.
For how to specify `FIELD_SIGNATURE`, please see <<Field Signature>>.

=== Sinks
Currently, our taint analysis supports specifying specific variables at call sites of sink methods as sinks.
In the configuration file, sinks are specified as a list of sink entries following key `sinks`:

[source,yaml]
----
sinks:
  - { method: METHOD_SIGNATURE, index: INDEX }
  - ...
----

If you write such a sink in the configuration, then when the taint analysis finds that method `METHOD_SIGNATURE` is called by call site _l_ and the variable at _l_ specified by `INDEX` points-to any taint objects, it will report the detected taint flows.

For how to specify `METHOD_SIGNATURE` and `INDEX`, please see <<Method Signature>> and <<Variable Index of A Method>>.

=== Taint Transfers
In taint analysis, taint is associated with the contents of the data, so that it can be transferred among objects, and such phenomenon is called _taint transfer_.
Taint transfer happens frequently in real code, and if we cannot handle them properly, many security vulnerabilities would be missed.

==== Introduction
Below we use an example to illustrate what taint transfer is and how it affects taint analysis.

[source,java,linenums]
----
String taint = getSecret(); // source
StringBuilder sb = new StringBuilder();
sb.append("abc");
sb.append(taint); // taint is transferred to sb
sb.append("xyz");
String s = sb.toString(); // taint is transferred to s
leak(s); // sink
----

Suppose that we consider `getSecret()` and `leak()` as source and sink, respectively.
In this example, the code at line 1 retrieves secret data (in form of a string) and stores it in variable `taint`, and the secret data will finally flow to sink (line 7) via two taint transfers:

1. The method call to `append()` at line 4 appends the contents of `taint` to `sb`, so the `StringBuilder` pointed to by `sb` contains the secret data and should also be treated as tainted data; in other words, `append()` at line 4 transfers taint from `taint` to `sb`.
2. The method call to `toString()` at line 6 converts the `StringBuilder` to a `String`, which contains the same contents of the `StringBuilder`, so the `String` includes the secret data; in other words, `toString()` transfers taint from `sb` to `s`.

In this example, if the taint analysis cannot propagate taint from `taint` to `sb` and from `sb` to `s`, it will fail to detect the privacy leakage.
To address such issues, our taint analysis allows users to specify which methods cause taint transfers, and propagates taint flow accordingly.

==== Configuration
In this section, we introduce how to configure taint transfers.
The essence of taint transfer is that the method calls to some methods will trigger propagation of taints from specific variables to some other variables of the call sites.
We call source of taint transfer _from-variable_, and target of taint transfer _to-variable_, e.g., for `sb.append(taint)` in the above example, `taint` is the from-variable and `sb` is the to-variable.

In the configuration file, taint transfers are specified as a list of transfer entries following key `transfers`, for example:

[source,yaml]
----
transfers:
  - { method: "<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>", from: 0, to: base }
  - { method: "<java.lang.StringBuilder: java.lang.String toString()>", from: base, to: result }
----

which can handle the taint transfers of the example in <<Introduction>>.
Specifically, The format of transfer entry is:

[source,yaml,subs="+normal"]
----
- { method: METHOD_SIGNATURE, from: INDEX, to: INDEX, [underline]#type: TYPE# }
----

Here, `METHOD_SIGNATURE` is the method that causes taint transfer, `from` and `to` specify the indexes of from-variable and to-variable at the call site.
`TYPE` is the type of the transferred taint object, which is also *optional*.

Taint transfer is complicated in real-world programs.
To detect more security vulnerabilities, our taint analysis supports several kinds of taint transfers.
You can write different expressions for `from` and `to` in transfer entries to enable different kinds of taint transfers, as listed below:

|===
| Transfer | From | To

| variable -> variable
| `INDEX`
| `INDEX`

| variable -> array
| `INDEX`
| `INDEX[*]`

| variable -> field
| `INDEX`
| `INDEX.FIELD_NAME`

| array -> variable
| `INDEX[*]`
| `INDEX`

| field -> variable
| `INDEX.FIELD_NAME`
| `INDEX`
|===

As a reference, we use an example here to show usefulness of array -> variable transfer.

[source,java,linenums]
----
String cmd = request.getParameter("cmd"); // source
Object[] cmds = new Object[]{cmd};
Expression expr = Factory.newExpression(cmds); // taint transfer: cmds[0] -> expr
execute(expr); // sink
----

Suppose that we consider `getParameter()` and `execute()` as source and sink, respectively.
In this example, the code at line 1 retrieves value from http request (which is uncontrollable and thus treated as source), and stores it in `cmd`.
The code at line 2 stores `cmd` into an `Object` array, which is used to create an `Expression` at line 3.
Finally, the `Expression` is passed to `execute()`, which may cause command injection.

To detect this injection, we need to propagate taint from `cmd` to `expr` when analyzing method call `expr = Factory.newExpression(cmds)`.
At this call, the taint stored in array `cmds` is passed to `expr`, and we can capture this behavior by writing such a taint transfer entry:

[source,yaml]
----
- { method: "<Factory: Expression newExpression(java.lang.Object[])>", from: "0[*]", to: result }
----

Here, `from: "0[*]"` means that the taint analysis will search _all elements_ in the array pointed to by _0-th parameter_ (i.e., `cmds`), and if it detects any taint objects, it will propagate them to the variable specified by `to: result` (i.e., `expr`).

NOTE: `[` and `]` are special characters in YAML, so you need to quote them like `"0[*]"`.

=== Sanitizers
Our taint analysis allows users to specify sanitizers to reduce false positives.
This can be done by writing a list of sanitizer entries following key `sanitizers` in the configuration:

[source,yaml]
----
sanitizers:
  - { kind: param, method: METHOD_SIGNATURE, index: INDEX }
  - ...
----

Then the taint analysis will block the propagation of taint objects to the parameter (specified by `INDEX`) of method `METHOD_SIGNATURE`.

// TODO: === Call-Site Mode

=== Multiple Configuration Files
The taint analysis can load multiple configuration files so that users do not need to write all configuration into one huge file.
User just needs to put all relevant configuration files into one directory, and pass the path of the directory (`<path/to/config>`) to Tai-e when enabling taint analysis.

TIP: The taint analysis will walk the directory iteratively when loading configuration, thus you can organize the configuration files as you wish, e.g., put them into multiple subdirectories.

== Output of Taint Analysis
Currently, the output of taint analysis consists of two parts: console output and taint flow graph.

=== Console Output
In console output, the taint analysis reports the detected taint flows with format:

[source]
----
Detected n taint flow(s):
TaintFlow{SOURCE_POINT -> SINK_POINT}
...
----

Each taint flow is a pair of source point and sink point.
A source point is a variable pointing to a new-generated taint object, and a sink point is a variable pointing to taint objects flowed from the source point.

Since we have several kinds of <<Sources>>, each kind of sources has a corresponding kind of source point:

[cols="1,2,2,3"]
|===
| Source | Source Point Description | Source Point Format | Explanation

| Call source
| A variable at a call site of the source method.
| `METHOD_SIGNATURE[i@Ln] CALL_STMT/INDEX`
a| * `METHOD_SIGNATURE`: The method containing the call site.
   * `[i@Ln]`: Position of the call site.
   * `CALL_STMT`: The call statement (site).
   * `INDEX`: <<Variable Index of A Call Site,Index>> of the source point variable.

| Parameter source
| A parameter of the source method.
| `METHOD_SIGNATURE/INDEX`
a| * `METHOD_SIGNATURE`: The source method.
   * `INDEX`: <<Variable Index of A Method,Index>> of the source point variable.

| Field source
| A variable that receives loaded value from the source field.
| `METHOD_SIGNATURE[i@Ln] LOAD_STMT`
a| * `METHOD_SIGNATURE`: The method containing the load statement.
   * `[i@Ln]`: Position of the load statement.
   * `LOAD_STMT`: The load statement.
|===

The `[i@Ln]` represent the position of a statement, where `i` is the index of the statement in the IR, and `n` is the line number of the statement in the source code, which can help you locate the statement.

Here we give some examples of source points:

* Call source: `<Main: void main(java.lang.String[])>[3@L7] pw = invokestatic Data.getPassword()/result`
* Parameter source: `<Controller: void doGet(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)>/0`
* Field source: `<Main: void main(java.lang.String[])> [29@L24] name = p.<Person: java.lang.String name>`

The format of the sink point is exactly the same as call source point, so we won't repeat the explanation here.

=== Taint Flow Graph
Console output only shows the start and end of the taint flows.
However, to validate the reported taint flows (and the relevant security vulnerabilities), users need to examine detailed propagation path of taint objects.
To meet such needs, we define _taint flow graph_ (TFG for short), whose nodes are the program pointers (e.g., variables and fields) that point to taint objects, and edges represent how taint objects flow among the pointers, so that users can check taint flows by going over the TFG.

Tai-e will output the path of the dumped TFG:

[source]
----
Dumping ...\tai-e\output\taint-flow-graph.dot
----

TFG is dumped as https://graphviz.org/doc/info/lang.html[DOT] graph.
For better experience, we recommend you install https://graphviz.org/[Graphviz] and use it to convert DOT to SVG via commend:

[source,shell]
----
$ dot -Tsvg taint-flow-graph.dot -o taint-flow-graph.svg
----

then you can open the TFG with your web browser and examine it.

// TODO: Explain what the different arrows and node shapes represent

NOTE: We will develop more user-friendly mechanism to examine taint analysis result in the future.

// TODO: == Troubleshooting
