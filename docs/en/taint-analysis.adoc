[[taint-analysis]]
include::attributes.adoc[]

= Taint Analysis

Tai-e provides a configurable and powerful taint analysis for detecting security vulnerabilities.
We develop taint analysis based on the pointer analysis framework, so that it can benefit from the techniques (e.g., various context sensitivity and heap abstraction techniques) and implementations (e.g., the handling of complex language features such as reflection and lambda functions) provided by the pointer analysis framework.
In this documentation, we introduce how to use our taint analysis.

== Enabling Taint Analysis
In Tai-e, taint analysis is designed and implemented as a plugin of pointer analysis framework.
To enable taint analysis, just start pointer analysis with option `taint-config`, for example:

[source,indent=0,subs="verbatim"]
----
-a pta=...;taint-config:<path/to/config>;...
----

then Tai-e will run taint analysis (together with pointer analysis) using a configuration file specified by `<path/to/config>` (if you need to specify multiple configuration files, please see <<Multiple Configuration Files>>).
We will introduce how to write a configuration file in the next section.

NOTE: You could use various pointer analysis techniques to obtain different precision/efficiency tradeoffs.
For more information, see <<pointer-analysis-framework#pointer-analysis-framework,Pointer Analysis Framework>>.

== Configuring Taint Analysis
In this section, we introduce how to configure sources, sinks, taint transfers, and sanitizers of the taint analysis through a configuration file written in YAML.
As an example. you could first take a look at https://github.com/pascal-lab/Tai-e/blob/master/src/test/resources/pta/taint/taint-config.yml[taint-config.yml] from our test cases to get a general impression.

=== General Notions
We first introduce some general notions used in the configuration.

==== Type
You may write following types in configuration.

[cols="1,2,2"]
|===
| Type | Description | Examples

| Class type
| Fully-qualified class name.
| `java.lang.String`, `org.example.MyClass`

| Array type
| A type following by one or more `[]`, where the number of `[]` equals the number of the array dimension.
| `java.lang.String[]`, `org.example.MyClass[][]`

| Primitive type
| The primitive types in Java.
| `int`, `char`, etc.
|===

==== Method Signature
In the configuration, we use method signature to uniquely identify a method in the program being analyzed.
The format of a method signature is given below:

[source,indent=0,subs="verbatim"]
----
<CLASS_TYPE: RETURN_TYPE METHOD_NAME(PARAMETER_TYPES)>
----

* `CLASS_TYPE`: The class in which the method is declared.
* `RETURN_TYPE`: The return type of the method.
* `METHOD_NAME`: The name of the method.
* `PARAMETER_TYPES`: The list of parameters types of the method.
Multiple parameter types are separated by `,` (NOTE: do not insert spaces around `,`).
If the method has no parameters, just write `()`.

For example, the signatures of methods `equals` and `toString` of `Object` are:

[source,indent=0,subs="verbatim"]
----
<java.lang.Object: boolean equals(java.lang.Object)>
<java.lang.Object: java.lang.String toString()>
----

==== Field Signature
Similar to methods, we use field signature to uniquely identify a field in the program being analyzed.
The format of a field signature is given below:

[source,indent=0,subs="verbatim"]
----
<CLASS_TYPE: FIELD_TYPE FIELD_NAME>
----

* `CLASS_TYPE`: The class in which the method is declared.
* `FIELD_TYPE`: The type of the field.
* `FIELD_NAME`: The name of the field.

For example, the signature of the field `info` below

[source,java,indent=0,subs="verbatim"]
----
package org.example;

class MyClass {
    String info;
}
----

is

[source,indent=0,subs="verbatim"]
----
<org.example.MyClass: java.lang.String info>
----

==== Variable Index
When configuring taint analysis, we usually need to specify a variable of a call site or a method, and this can be done by _variable index_.

===== Variable Index of A Call Site
We classify variables at a call site into following kinds:

[cols="1,3,1"]
|===
| Kind | Description | Index

| Result variable
| The variable that receives the result of the method call, i.e., the LHS variable of the call site.
| `result`

| Base variable
| The variable that points to the receiver object of the method call. This variable is absent for static method calls.
| `base`

| Arguments
| The arguments of the call site, counting from 0.
| `0`, `1`, `2`, ...
|===

For example, for a method call

[source,java,indent=0,subs="verbatim"]
----
r = o.foo(p, q);
----

* The index of variable `r` is `result`.
* The index of variable `o` is `base`.
* The indexes of variables `p` and `q` are `0` and `1`.

===== Variable Index of A Method
Currently, we support specifying parameters of a method using indexes.
Similar to arguments of a call site, the parameters are counted from 0.
For example, the indexes of parameters `t`, `s`, and `o` of method `foo` below are `0`, `1`, and `2`.

[source,java,indent=0,subs="verbatim"]
----
package org.example;

class MyClass {
    void foo(T t, String s, Object o) {
        ...
    }
}
----

=== Sources
Taint objects are generated by sources.
In the configuration file, sources are specified as a list of source entries following key `sources`, for example:

[source,yaml,indent=0,subs="verbatim"]
----
sources:
  - { kind: call, method: "<javax.servlet.ServletRequestWrapper: java.lang.String getParameter(java.lang.String)>", index: result }
  - { kind: param, method: "<com.example.Controller: java.lang.String index(javax.servlet.http.HttpServletRequest)>", index: 0 }
  - { kind: field, field: "<SourceSink: java.lang.String info>" }
----

Our taint analysis supports several kinds of sources, as introduced in the next sections.

==== Call Sources
This should be the most-commonly used source kind, for the cases that the taint objects are generated at call sites.
The format of this kind of sources is:

[source,yaml,indent=0,subs="verbatim"]
----
- { kind: call, method: METHOD_SIGNATURE, index: INDEX, type: TYPE }
----

If you write such a source in the configuration, then when the taint analysis finds that method  `METHOD_SIGNATURE` is called by call site _l_, it will generate a taint object of type `TYPE` for the variable specified by `INDEX` at call site _l_.
For how to specify `METHOD_SIGNATURE` and `INDEX`, please see <<Method Signature>> and <<Variable Index of A Call Site>>.

`type: TYPE` in the call source configuration is *optional*.
When it is omitted, the taint analysis will use corresponding declared type from the method (return type for _result variable_, declaring class type for _base variable_, and parameter types for _arguments_) as the type for the generated taint object.

==== Parameter Sources
Some methods, e.g., entry methods, have no explicit call sites in the program, so we cannot generate taint objects for the variables at their call sites.
However, it is sometime useful to generate taint objects for their parameters.
To meet such needs, our taint analysis allows you to configure parameter sources:

[source,yaml,indent=0,subs="verbatim"]
----
- { kind: param, method: METHOD_SIGNATURE, index: INDEX, type: TYPE }
----

If you write such a source in the configuration, then when the taint analysis finds that method `METHOD_SIGNATURE` is reachable, it will generate a taint object of type `TYPE` for the parameter specified by `INDEX`.
For how to specify `METHOD_SIGNATURE` and `INDEX`, please see <<Method Signature>> and <<Variable Index of A Method>>.

Similar to call sources, `type: TYPE` in the parameter source configuration is *optional*.

==== Field Sources
Our taint analysis also supports users to specify fields as taint sources using format:

[source,yaml,indent=0,subs="verbatim"]
----
- { kind: field, field: FIELD_SIGNATURE, type: TYPE }
----

If you write such a source in the configuration, then when the taint analysis finds that field `FIELD_SIGNATURE` is loaded to variable `v` (e.g., `v = o.f`), it will generate a taint object of type `TYPE` for `v`.
For how to specify `FIELD_SIGNATURE`, please see <<Field Signature>>.
Similarly, `type: TYPE` in the field source configuration is also *optional*.

=== Sinks
Currently, our taint analysis supports specifying specific variables at call sites of sink methods as sinks.
In the configuration file, sinks are specified as a list of sink entries following key `sinks`:

[source,yaml,indent=0,subs="verbatim"]
----
sinks:
  - { method: METHOD_SIGNATURE, index: INDEX }
  - ...
----

If you write such a sink in the configuration, then when the taint analysis finds that method `METHOD_SIGNATURE` is called by call site _l_ and the variable at _l_ specified by `INDEX` points-to any taint objects, it will report the detected taint flows.

For how to specify `METHOD_SIGNATURE` and `INDEX`, please see <<Method Signature>> and <<Variable Index of A Method>>.

=== Taint Transfers
In taint analysis, taint is associated with the contents of the data, so that it can be transferred among objects, and such phenomenon is called _taint transfer_.
Taint transfer happens frequently in real code, and if we cannot handle them properly, many security vulnerabilities would be missed.

==== Introduction
Below we use an example to illustrate what taint transfer is and how it affects taint analysis.

[source,java,linenums,indent=0,subs="verbatim"]
----
String taint = getSecret(); // source
StringBuilder sb = new StringBuilder();
sb.append("abc");
sb.append(taint); // taint is transferred to sb
sb.append("xyz");
String s = sb.toString(); // taint is transferred to s
leak(s); // sink
----

Suppose that we consider `getSecret()` and `leak()` as source and sink, respectively.
In this example, the code at line 1 retrieves secret data (in form of a string) and stores it in variable `taint`, and the secret data will finally flow to sink (line 7) via two taint transfers:

1. The method call to `append()` at line 4 appends the contents of `taint` to `sb`, so the `StringBuilder` pointed to by `sb` contains the secret data and should also be treated as tainted data; in other words, `append()` at line 4 transfers taint from `taint` to `sb`.
2. The method call to `toString()` at line 6 converts the `StringBuilder` to a `String`, which contains the same contents of the `StringBuilder`, so the `String` includes the secret data; in other words, `toString()` transfers taint from `sb` to `s`.

In this example, if the taint analysis cannot propagate taint from `taint` to `sb` and from `sb` to `s`, it will fail to detect the privacy leakage.
To address such issues, our taint analysis allows users to specify which methods cause taint transfers, and propagates taint flow accordingly.

==== Configuration
In this section, we introduce how to configure taint transfers.
The essence of taint transfer is that the method calls to some methods will trigger propagation of taints from specific variables to some other variables of the call sites.
We call source of taint transfer _from-variable_, and target of taint transfer _to-variable_, e.g., for `sb.append(taint)` in the above example, `taint` is the from-variable and `sb` is the to-variable.

In the configuration file, taint transfers are specified as a list of transfer entries following key `transfers`, for example:

[source,yaml,indent=0,subs="verbatim"]
----
transfers:
  - { method: "<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>", from: 0, to: base }
  - { method: "<java.lang.StringBuilder: java.lang.String toString()>", from: base, to: result }
----

which can handle the taint transfers of the example in <<Introduction>>.
Specifically, The format of transfer entry is:

[source,yaml,indent=0,subs="verbatim"]
----
- { method: METHOD_SIGNATURE, from: INDEX, to: INDEX, type: TYPE }
----

Here, `METHOD_SIGNATURE` is the method that causes taint transfer, `from` and `to` specify the indexes of from-variable and to-variable at the call site.
`TYPE` is the type of the transferred taint object, which is also *optional*.

Taint transfer is complicated in real-world programs.
To detect more security vulnerabilities, our taint analysis supports several kinds of taint transfers.
You can write different expressions for `from` and `to` in transfer entries to enable different kinds of taint transfers, as listed below:

|===
| Transfer | From | To

| variable -> variable
| `INDEX`
| `INDEX`

| variable -> array
| `INDEX`
| `INDEX[*]`

| variable -> field
| `INDEX`
| `INDEX.FIELD_NAME`

| array -> variable
| `INDEX[*]`
| `INDEX`

| field -> variable
| `INDEX.FIELD_NAME`
| `INDEX`
|===

As a reference, we use an example here to show usefulness of array -> variable transfer.

[source,java,linenums,indent=0,subs="verbatim"]
----
String cmd = request.getParameter("cmd"); // source
Object[] cmds = new Object[]{cmd};
Expression expr = Factory.newExpression(cmds); // taint transfer: cmds[0] -> expr
execute(expr); // sink
----

Suppose that we consider `getParameter()` and `execute()` as source and sink, respectively.
In this example, the code at line 1 retrieves value from http request (which is uncontrollable and thus treated as source), and stores it in `cmd`.
The code at line 2 stores `cmd` into an `Object` array, which is used to create an `Expression` at line 3.
Finally, the `Expression` is passed to `execute()`, which may cause command injection.

To detect this injection, we need to propagate taint from `cmd` to `expr` when analyzing method call `expr = Factory.newExpression(cmds)`.
At this call, the taint stored in array `cmds` is passed to `expr`, and we can capture this behavior by writing such a taint transfer entry:

[source,yaml,indent=0,subs="verbatim"]
----
- { method: "<Factory: Expression newExpression(java.lang.Object[])>", from: "0[*]", to: result }
----

Here, `from: "0[*]"` means that the taint analysis will search _all elements_ in the array pointed to by _0-th parameter_ (i.e., `cmds`), and if it detects any taint objects, it will propagate them to the variable specified by `to: result` (i.e., `expr`).

NOTE: `[` and `]` are special characters in YAML, so you need to quote them like `"0[*]"`.

=== Sanitizers

// TODO: === Call-Site Mode

=== Multiple Configuration Files

== Output of Taint Analysis

console:

[source,indent=0,subs="verbatim"]
----
Detected n taint flow(s):
TaintFlow{SOURCE_POINT -> SINK_POINT}
...
----

[source,indent=0,subs="verbatim"]
----
Detected 1 taint flow(s):
TaintFlow{<Server: void main(java.lang.String[])>[12@L8] temp$4 = invokestatic Server.getInput()/result -> <org.apache.logging.log4j.core.net.JndiManager: java.lang.Object lookup(java.lang.String)>[1@L172] $r3 = invokeinterface $r2.lookup(name)/0}
----

_taint flow graph_ (TFG)

// TODO: == Troubleshooting
