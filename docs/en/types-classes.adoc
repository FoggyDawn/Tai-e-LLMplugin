include::attributes.adoc[]

= How to Specify and Access Types, Classes, and Class Members (Methods and Fields)

Java programs are built using types and classes, which consist of class members such as methods and fields.
Tai-e assigns a unique identifier, known as a signature, to each type, class, and class member.
These signatures enable users to easily configure and specify the behavior of program analyzers for specific elements, such as in taint configuration (see <<taint-analysis#configuring-taint-analysis,How to Use Taint Analysis?>>).
Additionally, they allow analysis developers to easily retrieve and manipulate program elements through Tai-e's convenient APIs.

In some cases, it may be necessary to specify _a large number_ of classes or class members within a configuration or when implementing a particular program analysis.
To streamline this process, we have designed and implemented various signature patterns and matchers for classes, methods, and fields, enabling you to specify and retrieve multiple elements using a single signature pattern.

This documentation will guide you through the format of signatures for types, classes, and class members, as well as the APIs for accessing these program elements via their signatures.

NOTE: Since generic types are erased in Java, type signatures, along with class and class member signatures, *do not include type parameters*.

== Type Signatures
In this section, we introduce the signatures for various Java types, including primitive types, reference types, and the `void` type.

=== Primitive Types
The signatures for the eight Java primitive types are simply their names: `byte`, `short`, `int`, `long`, `float`, `double`, `char`, and `boolean`.

=== Reference Types
Java reference types include class types (encompassing interfaces and enums) and array types.
The signature formats for these types are outlined below.

==== Class Types (Including Interfaces and Enums)
The signature for a class type is its fully-qualified class name, which includes the package name.
For an inner class, insert a `$` between the outer class name and the inner class name.
Here are some examples:

* `java.lang.String`
* `pascal.taie.Main`
* `org.example.MyClass`
* `java.util.Map$Entry`

==== Array Types
An array type signature consists of its base type followed by one or more `[]`, with the number of `[]` indicating the array's dimensions.
Here are some examples:

* `java.lang.String[]`
* `org.example.MyClass[][]`
* `char[]`

=== Void Type
The signature for the void type is simply void. This appears in <<Method Signature,Method Signature>> for methods that do not return a value.

=== Programmatically Accessing a Type via Signature
For analysis developers, Tai-e provides convenient APIs to access various types. All the classes related to types, mentioned below, are located in the `pascal.taie.language.type package`.

In Tai-e, the `TypeSystem` class (accessible via `World.get().getTypeSystem()`) offers APIs to retrieve all types (except `void`, which is discussed later):

* `TypeSystem.getPrimitiveType(String)`: Retrieves a primitive type by its signature.
* `TypeSystem.getClassType(String)`: Retrieves a class type by its signature.
* `TypeSystem.getArrayType(Type,int)`: Retrieves an array type by its base type and the number of dimensions.
* `TypeSystem.getType(String)`: Retrieves a primitive type, class type, or array type by its signature.

Additionally, primitive types and the `void` type are implemented as enums in Tai-e, and can be directly accessed through their respective classes, such as `IntType.INT` and `VoidType.VOID`.

== Class and Class Member Signatures
In this section, we introduce the signatures for classes and their members, specifically methods and fields.
While constructors are typically considered class members, in Tai-e, they are treated as methods with a special name, as explained in <<Method Signatures,Method Signatures>>.

=== Class Signatures
Unsurprisingly, the format for class signatures is identical to that of <<Class Types (Including Interfaces and Enums),class types>>, so we wonâ€™t repeat the details here.

=== Method Signatures
The format of a method signature is as follows:

[source]
----
<CLASS_TYPE: RETURN_TYPE METHOD_NAME(PARAMETER_TYPES)>
----

* `CLASS_TYPE`: The signature of the class in which the method is declared.
* `RETURN_TYPE`: The signature of the method's return type.
* `METHOD_NAME`: The name of the method.
* `PARAMETER_TYPES`: A `,`-separated list of parameter type signatures (Do not insert spaces around the `,`!).
If the method has no parameters, use `()`.

Here are some examples of method signatures:

[source]
----
<java.lang.Object: java.lang.String toString()>
<java.lang.Object: boolean equals(java.lang.Object)>
<java.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)>
----

As mentioned earlier, *constructors* are treated as methods in Tai-e.
Each constructor has the name `<init>`, and its return type is always `void`.
For example, the constructor signatures for `ArrayList` are:

[source]
----
<java.util.ArrayList: void <init>()>
<java.util.ArrayList: void <init>(int)>
<java.util.ArrayList: void <init>(java.util.Collection)>
----

Another special class member is the *static initializer* (also known as the class initializer), which is treated as a method with no arguments and no return value in Tai-e.
The method name for a static initializer is `<clinit>`.
For example, the signature of static initializer for `Object` is `<java.lang.Object: void <clinit>()>`.

=== Field Signatures
Like methods, field signatures uniquely identify fields within a Java program.
The format of a field signature is as follows:

[source]
----
<CLASS_TYPE: FIELD_TYPE FIELD_NAME>
----

* `CLASS_TYPE`: The signature of the class where the field is declared.
* `FIELD_TYPE`: The signature of the field's type.
* `FIELD_NAME`: The name of the field.

For example, the signature for the field `info` in the following code:

[source,java]
----
package org.example;

class MyClass {
    String info;
}
----

is:

[source]
----
<org.example.MyClass: java.lang.String info>
----

=== Programmatically Accessing a Class or Member via Signature
Tai-e offers convenient APIs through the `pascal.taie.language.classes.ClassHierarchy` class, allowing analysis developers to access a class or member by its signature.
The available methods are:

* `ClassHierarchy.getClass(String)`: Retrieves a class (`JClass`) by its signature.
* `ClassHierarchy.getMethod(String)`: Retrieves a method (`JMethod`) by its signature.
* `ClassHierarchy.getField(String)`: Retrieves a field (`JField`) by its signature.

== Signature Pattern


* name wildcard (class name, method name, field name, and type name in method and field signature)

=== Class Signature Pattern
* subclass wildcard

=== Method Signature Pattern
* parameter wildcard

=== Field Signature Pattern
The format of field signature pattern is simpler than method signature pattern, since a field signature is essentially a method signature without parameter list.

=== Programmatically Accessing Multiple Classes or Members via Signature Pattern
Tai-e provides convenient APIs for analysis developers to retrieve multiple classes or members using signature patterns.
To use these, developers first create a `pascal.taie.language.classes.SignatureMatcher` object, passing a `ClassHierarchy` as an argument.
They can then use the following APIs:

* `SignatureMatcher.getClasses(String)`: Retrieves classes (`JClass`) based on the specified signature pattern.
* `SignatureMatcher.getMethods(String)`: Retrieves methods (`JMethod`) based on the specified signature pattern.
* `SignatureMatcher.getFields(String)`: Retrieves fields (`JField`) based on the specified signature pattern.
