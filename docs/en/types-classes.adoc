include::attributes.adoc[]

= How to Specify and Access Types, Classes, and Class Members (Methods and Fields)
Java programs are built using types and classes, which consist of class members such as methods and fields.
Tai-e assigns a unique identifier, known as a signature, to each type, class, and class member.
These signatures enable users to easily configure and specify the behavior of program analyzers for specific elements, such as in taint configuration (see <<taint-analysis#configuring-taint-analysis,How to Use Taint Analysis?>>).
Additionally, they allow analysis developers to easily retrieve and manipulate program elements through Tai-e's convenient APIs.

In some cases, it may be necessary to specify _a large number_ of classes or class members within a configuration or when implementing a particular program analysis.
To streamline this process, we have designed and implemented signature wildcards, which allow you to specify multiple classes and class members using a single wildcard signature.

This documentation will guide you through the format of signatures for types, classes, and class members, as well as the APIs for accessing these program elements via their signatures.

NOTE: Since generic types are erased in Java, type signatures, along with class and class member signatures, *do not include type parameters*.

== Type Signatures
In this section, we introduce the signatures for various Java types, including primitive types, reference types, and the `void` type.

=== Primitive Types
The signatures for the eight Java primitive types are simply their names: `byte`, `short`, `int`, `long`, `float`, `double`, `char`, and `boolean`.

=== Reference Types
Java reference types include class types (encompassing interfaces and enums) and array types.
The signature formats for these types are outlined below.

==== Class Types (Including Interfaces and Enums)
The signature for a class type is its fully-qualified class name, which includes the package name.
For an inner class, insert a `$` between the outer class name and the inner class name.
Here are some examples:

* `java.lang.String`
* `pascal.taie.Main`
* `org.example.MyClass`
* `java.util.Map$Entry`

==== Array Types
An array type signature consists of its base type followed by one or more `[]`, with the number of `[]` indicating the array's dimensions.
Here are some examples:

* `java.lang.String[]`
* `org.example.MyClass[][]`
* `char[]`

=== Void Type
The signature for the void type is simply void. This appears in <<Method Signature,Method Signature>> for methods that do not return a value.

=== Programmatically Accessing a Type via Signature
For analysis developers, Tai-e provides convenient APIs to access various types. All the classes related to types, mentioned below, are located in the `pascal.taie.language.type package`.

In Tai-e, the `TypeSystem` class (accessible via `World.get().getTypeSystem()`) offers APIs to retrieve all types (except `void`, which is discussed later):

* `TypeSystem.getPrimitiveType(String)`: Retrieves a primitive type by its signature.
* `TypeSystem.getClassType(String)`: Retrieves a class type by its signature.
* `TypeSystem.getArrayType(Type,int)`: Retrieves an array type by its base type and the number of dimensions.
* `TypeSystem.getType(String)`: Retrieves a primitive type, class type, or array type by its signature.

Additionally, primitive types and the `void` type are implemented as enums in Tai-e, and can be directly accessed through their respective classes, such as `IntType.INT` and `VoidType.VOID`.

== Class and Class Member Signatures
In this section, we introduce the signatures for classes and their members, specifically methods and fields.
While constructors are typically considered class members, in Tai-e, they are treated as methods with a special name, as explained in <<Method Signatures,Method Signatures>>.

=== Class Signatures
Unsurprisingly, the format for class signatures is identical to that of <<Class Types (Including Interfaces and Enums),class types>>, so we wonâ€™t repeat the details here.

=== Method Signatures

* constructor
* class initializer

=== Field Signatures

=== Programmatically Accessing a Class or Member via Signature

== Signature Wildcard
